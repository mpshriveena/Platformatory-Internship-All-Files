Error Handling Concepts

1) Platform vs. Application Failures
Platform Failures
Platform failures occur due to issues with the server, network, or other environmental factors that are beyond the control of the Workflow’s logic. 

Application Failures
Application failures are the type of failure that most developers are familiar with, and are generated by user code. They indicate an issue with your application logic. For instance, an application failure might occur if a user submits a form with invalid data, causing the application to raise a validation error

Backward and Forward Recovery
Application failures often involve backward recovery, a process where the system undoes some of the work that has already been performed to return to a previous state. By contrast, platform failures typically involve forward recovery. Forward recovery is a process where the system attempts to retry the failed operation, and if the retry succeeds, the application continues from the point of failure without undoing any previous work.

2) The Temporal Error Model
Temporal converts errors into common format

3) Three Conceptual Types of Failure

Transient Failures
A Transient failure is unlikely to affect future requests. A transient failure can be resolved by retrying the request soon after the failure

Intermittent Failures
Intermittent failure is a failure that happened in the past is likely to occur again in the future. Consider the example of requests made to a service that uses rate limiting. Requests will succeed until the threshold is reached, after which new requests will fail until the rate limiter is reset. Like transient failures, intermittent failures can be addressed by retrying the requests, but these retries should be spread out over a longer period of time to avoid overloading the system and allow the underlying cause to be resolved.

Permanent Failures
Permanent failures are the failures in which a failure is guaranteed to recur until the cause is repaired. Permanent failures cannot be resolved solely through retries.

4) Idempotence

Idempotence is a property in which the change in state achieved by invoking an operation is unaffected by subsequent invocations. Due to this, idempotent operations can safely be invoked more than once without adversely affecting application state.

Activity Idempotence
When implementing business logic in Temporal, it is strongly recommended that you make your Activities idempotent. Because Activities have the possibility of being retried, these functions may be executed more than once. A non-idempotent Activity could adversely affect the state of the system.

At Least Once Execution

Using Unique Identifiers to Guarantee Idempotency
You can achieve idempotency in your application through the use of unique identifiers, known as idempotency keys, which are used to detect duplicate requests. These are enforced by the service you are calling from your Activity, not by the Activity itself.
For example, the APIs provided by most payment processors allow the client to include an idempotency key with the request. When the payment service receives a request, it checks a database to determine whether there has already been a request with this key. If so, the duplicate request is ignored and does not result in another charge. If not, then it writes a new record to the database with this key, allowing it to identify duplicate requests in the future.
In Temporal, the request to the payment service would be made from within an Activity. You can use a combination of the Workflow Run ID and the Activity ID as an idempotency key since this is guaranteed to be consistent across retry attempts but unique among Workflow Executions.
Here is an example of how to do so:

from temporalio import activity
info = activity.info()
idempotency_key = f"{info.workflow_run_id}-{info.activity_id}"

The value of the idempotency_key will be constant across Activity retries, and unique among all Workflow Executions. It is important to use the Run ID and not the Workflow ID as these IDs can be reused.

5) How Temporal Represents Failures

Temporal Error
The Python base exception for Activities and Workflows is TemporalError.
You should not extend the TemporalError class or any of its children.

Activity Error
When you raise an exception from an Activity, it will be surfaced as an ActivityError
For example, if an Activity gets cancelled or times out, the corresponding call in the Workflow Execution will raise an ActivityError error, with its cause being a CancellationError, or a TimeoutError
Insteresting Point: You can also raise an ApplicationError from a Workflow Execution. This will fail the Workflow Execution. The only Temporal exception designed to be raised manually from your Workflow code is an ApplicationError

Temporal Failure Types

ApplicationError
CancelledError
TerminatedError
TimeoutError
ServerError
ChildWorkflowError
WorkflowAlreadyStartedError
ActivityError

Failure Converters
When Temporal raises an exception, it invokes what is called a Failure Converter. The default Failure Converter copies exception messages and stack traces as plain text, and this text output is then accessible in the message field visible to the Temporal Web UI or from the CLI.
If your exceptions might contain sensitive information, you can encrypt the message and stack trace by configuring the Failure Converter to use a custom codec.

6) Workflow Task Failures vs Workflow Execution Failures

A Workflow Execution is the sequence of steps that results from executing a Workflow Definition.
    A Workflow Execution includes Workflow Tasks.
        A Workflow Execution Failure is not retried by default.
    A Workflow Task is a single step within a Workflow Execution.
        A Workflow Task Failure is retried by default.

7) How Executions and Failures Appear in the Event History
How Activity Executions Appear in the Event History
ActivityTaskScheduled --> Task added to the Task Queue
ActivityTaskStarted --> accepted by the Worker
ActivityTaskCompleted --> Worker notifying the Temporal Service of the successful result

The ActivityTaskStarted and ActivityTaskCompleted Events are written to the history at the same time
To recap, while an Activity is running, ActivityTaskScheduled will be the most recent Event visible for that Activity.

Workflow Execution Failures
When a Workflow Execution does fail, the Temporal Service adds a WorkflowExecutionFailed event to the Event History. If an unhandled Activity failure leads to a Workflow Execution failure — i.e., by ignoring the failure and letting it propagate up or by catching an Activity failure and re-raising an ApplicationFailure.